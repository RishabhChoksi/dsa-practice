[
  {
  "problem": {
    "id": 0,
    "topic": "Arrays",
    "source": "Leetcode",
    "url": "https://leetcode.com/problems/maximum-subarray/description/",
    "tags": [
      "arrays"
    ],
    "difficultyLevel": "Medium"
  },
  "question": {
    "heading": "Maximum Subarray",
    "question": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
    "headingImages": [
       ],
    "examples": [
      {
        "id": 0,
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "id": 1,
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The subarray [1] has the largest sum 1."
      },
      {
        "id": 2,
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "hints": [
      "If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle."
    ]
  },
  "solution": {
"solution": "class Solution {\n    public int maxSubArray(int[] nums) {\n\n        /*\n        Solution: 1\n        Simply iterate over the nums array and maintain a currentSum and maxsum\n        If current sum is becoming negative, update it to zero to avoid negative\n        contribution to the sum\n        */\n\n        int ans = nums[0], currentSum = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            // Never lets it become negative\n            currentSum = Math.max(currentSum, 0);\n            currentSum += nums[i];\n            ans = Math.max(currentSum, ans);\n        }\n\n        return ans;\n\n    }\n}"  }
},

{
  "problem": {
    "id": 1,
    "topic": "Arrays",
    "source": "Leetcode",
    "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/",
    "tags": [
      "arrays","dynamic programming"
    ],
    "difficultyLevel": "Easy"
  },
  "question": {
    "heading": "Best Time to Buy and Sell Stock",
    "question": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "headingImages": [
       ],
    "examples": [
      {
        "id": 0,
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell."
      },
      {
        "id": 1,
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= nums[i] <= 10^4"
    ],
    "hints": [
    ]
  },
  "solution": {
    "solution": "class Solution {\n    public int maxProfit(int[] prices) {\n        /*\n        Solution 1:\n        The idea is to start from day 1 and maintain a previous minimum\n        and keep subtracting it current item ans store max profit\n        */\n        int min = prices[0], ans = 0;\n        for (int i = 1; i < prices.length; i++) {\n            int maxProfit = prices[i] - min;\n            //Only if maxProfit is greater than 0, update it,else default it to 0\n            if (maxProfit > 0) {\n                ans = Math.max(ans, maxProfit);\n            }\n            min = Math.min(min, prices[i]);\n        }\n        return ans;\n    }\n}"
  }
},

{
  "problem": {
    "id": 2,
    "topic": "Arrays",
    "source": "Leetcode",
    "url": "https://leetcode.com/problems/product-of-array-except-self/description/",
    "tags": [
      "arrays","prefix sum"
    ],
    "difficultyLevel": "Medium"
  },
  "question": {
    "heading": "Product of Array Except Self",
    "question": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
    "headingImages": [
       ],
    "examples": [
      {
        "id": 0,
        "input": "nums = [1,2,3,4]",
        "output": "[24,12,8,6]",
        "explanation": "The product of all the elements of nums except nums[0] is 2*3*4 = 24.\nThe product of all the elements of nums except nums[1] is 1*3*4 = 12.\nThe product of all the elements of nums except nums[2] is 1*2*4 = 8.\nThe product of all the elements of nums except nums[3] is 1*2*3 = 6."
      },
      {
        "id": 1,
        "input": "nums = [-1,1,0,-3,3]",
        "output": "[0,0,9,0,0]",
        "explanation": "The product of all the elements of nums except nums[0] is 1*0*-3*3 = 0.\nThe product of all the elements of nums except nums[1] is -1*0*-3*3 = 0.\nThe product of all the elements of nums except nums[2] is -1*1*-3*3 = 9.\nThe product of all the elements of nums except nums[3] is -1*1*0*3 = 0.\nThe product of all the elements of nums except nums[4] is -1*1*0*-3 = 0."
      }
    ],
    "constraints": [
      "2 <= prices.length <= 10^5",
      "-30 <= nums[i] <= 30",
      "The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer."
    ],
    "hints": [
    ]
  },
  "solution": {
    "solution": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        /*\n        Since we can't use division operation, we come up with idea\n        of right shifting and left shifting the products.\n        For eg, ans[2] = nums[0] * nums[1] * nums[3]\n        We skip nums[2] by right shifting the products by adding 1 \n        at start and similarly left shifting the products by adding 1\n        at end.\n        */\n\n        int n = nums.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        // Create left array\n        left[0] = 1;\n        for (int i = 1; i < n; i++) {\n            /* \n            we can't replace left[i-1] to nums[i-1], we want\n            previous computed result. nums should start from 0 hence, nums[i-1] \n            */\n            left[i] = left[i - 1] * nums[i - 1];\n        }\n\n        // create right array\n        right[n - 1] = 1;\n        for (int i = n - 2; i > -1; i--) {\n            right[i] = nums[i + 1] * right[i + 1];\n        }\n\n        // Multiply products and reuse nums array\n        for (int i = 0; i < nums.length; i++) {\n            nums[i] = left[i] * right[i];\n        }\n\n        return nums;\n    }\n}"
  }
}
,
{
  "problem": {
    "id": 3,
    "topic": "Arrays",
    "source": "Leetcode",
    "url": "https://leetcode.com/problems/rotate-array/description/",
    "tags": [
      "arrays","math", "two pointers"
    ],
    "difficultyLevel": "Medium"
  },
  "question": {
    "heading": "Rotate Array",
    "question": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
    "headingImages": [
       ],
    "examples": [
      {
        "id": 0,
        "input": "nums = [1,2,3,4,5,6,7], k = 3",
        "output": "[5,6,7,1,2,3,4]",
        "explanation": "rotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]"
      },
      {
        "id": 1,
        "input": "nums = [-1,-100,3,99], k = 2",
        "output": "[3,99,-1,-100]",
        "explanation": "rotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-2^31 <= nums[i] <= 2^31 - 1",
      "0 <= k <= 10^5"
    ],
    "hints": [
    ]
  },
  "solution": {
    "solution": "class Solution {\n    public void rotate(int[] nums, int k) {\n        /*\n        If k=n, then its one full rotation, hence no change in result\n        hence, if k=71, n=70, only one rotation k=k%n optimizes k\n        Solution 1: Standard way to reverse is 3 steps:\n        Reverse whole array, Reverse 0-k elements, Reverse k-n elements\n        */\n        int n = nums.length;\n        k = k % n;\n        reverse(0, n - 1, nums);\n        reverse(0, k - 1, nums);\n        reverse(k, n - 1, nums);\n    }\n\n    public void reverse(int start, int end, int[] arr) {\n        while (start < end) {\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n\n}"
  }
}

]